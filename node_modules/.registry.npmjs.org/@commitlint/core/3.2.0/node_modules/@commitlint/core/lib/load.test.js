'use strict';

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _load = require('./load');

var _load2 = _interopRequireDefault(_load);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cwd = process.cwd();

_ava2.default.afterEach.always(function (t) {
	t.context.back();
});

(0, _ava2.default)('extends-empty should have no rules', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/extends-empty');
		return Promise.resolve((0, _load2.default)()).then(function ($await_1) {
			try {
				actual = $await_1;
				t.deepEqual(actual.rules, {});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('uses seed as configured', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/extends-empty');
		return Promise.resolve((0, _load2.default)({ rules: { foo: 'bar' } })).then(function ($await_2) {
			try {
				actual = $await_2;
				t.is(actual.rules.foo, 'bar');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('uses seed with parserPreset', function (t) {
	return new Promise(function ($return, $error) {
		var _ref, actual;

		t.context.back = chdir('fixtures/parser-preset');

		return Promise.resolve((0, _load2.default)({ parserPreset: './conventional-changelog-custom' })).then(function ($await_3) {
			try {
				_ref = $await_3, actual = _ref.parserPreset;

				t.is(actual.name, './conventional-changelog-custom');
				t.deepEqual(actual.opts, {
					parserOpts: {
						headerPattern: /^(\w*)(?:\((.*)\))?-(.*)$/
					}
				});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('invalid extend should throw', function (t) {
	t.context.back = chdir('fixtures/extends-invalid');
	t.throws((0, _load2.default)());
});

(0, _ava2.default)('empty file should have no rules', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/empty-object-file');
		return Promise.resolve((0, _load2.default)()).then(function ($await_4) {
			try {
				actual = $await_4;
				t.deepEqual(actual.rules, {});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('empty file should extend nothing', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/empty-file');
		return Promise.resolve((0, _load2.default)()).then(function ($await_5) {
			try {
				actual = $await_5;
				t.deepEqual(actual.extends, []);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('recursive extends', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/recursive-extends');
		return Promise.resolve((0, _load2.default)()).then(function ($await_6) {
			try {
				actual = $await_6;
				t.deepEqual(actual, {
					extends: ['./first-extended'],
					rules: {
						zero: 0,
						one: 1,
						two: 2
					}
				});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('parser preset overwrites completely instead of merging', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/parser-preset-override');
		return Promise.resolve((0, _load2.default)()).then(function ($await_7) {
			try {
				actual = $await_7;

				t.is(actual.parserPreset.name, './custom');
				t.is(typeof actual.parserPreset.opts, 'object');
				t.deepEqual(actual.parserPreset.opts, {
					b: 'b',
					parserOpts: {
						headerPattern: /.*/
					}
				});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('recursive extends with parserPreset', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/recursive-parser-preset');
		return Promise.resolve((0, _load2.default)()).then(function ($await_8) {
			try {
				actual = $await_8;

				t.is(actual.parserPreset.name, './conventional-changelog-custom');
				t.is(typeof actual.parserPreset.opts, 'object');
				t.deepEqual(actual.parserPreset.opts.parserOpts.headerPattern, /^(\w*)(?:\((.*)\))?-(.*)$/);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('ignores unknow keys', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/trash-file');
		return Promise.resolve((0, _load2.default)()).then(function ($await_9) {
			try {
				actual = $await_9;
				t.deepEqual(actual, {
					extends: [],
					rules: {
						foo: 'bar',
						baz: 'bar'
					}
				});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('ignores unknow keys recursively', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/trash-extend');
		return Promise.resolve((0, _load2.default)()).then(function ($await_10) {
			try {
				actual = $await_10;
				t.deepEqual(actual, {
					extends: ['./one'],
					rules: {
						zero: 0,
						one: 1
					}
				});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('supports legacy .conventional-changelog-lintrc', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/legacy');
		return Promise.resolve((0, _load2.default)()).then(function ($await_11) {
			try {
				actual = $await_11;
				t.deepEqual(actual, {
					extends: [],
					rules: {
						legacy: true
					}
				});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('commitlint.config.js overrides .conventional-changelog-lintrc', function (t) {
	return new Promise(function ($return, $error) {
		var actual;

		t.context.back = chdir('fixtures/overriden-legacy');
		return Promise.resolve((0, _load2.default)()).then(function ($await_12) {
			try {
				actual = $await_12;
				t.deepEqual(actual, {
					extends: [],
					rules: {
						legacy: false
					}
				});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

function chdir(target) {
	var to = _path2.default.resolve(cwd, target.split('/').join(_path2.default.sep));
	process.chdir(to);
	return function () {
		return process.chdir(cwd);
	};
}
//# sourceMappingURL=load.test.js.map