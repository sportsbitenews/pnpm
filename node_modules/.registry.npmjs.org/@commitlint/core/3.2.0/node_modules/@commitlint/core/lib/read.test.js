'use strict';

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _os = require('os');

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _path = require('path');

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _denodeify = require('denodeify');

var _denodeify2 = _interopRequireDefault(_denodeify);

var _execa = require('execa');

var _execa2 = _interopRequireDefault(_execa);

var _fs = require('mz/fs');

var _pathExists = require('path-exists');

var _pathExists2 = _interopRequireDefault(_pathExists);

var _rimraf = require('rimraf');

var _rimraf2 = _interopRequireDefault(_rimraf);

var _package = require('../package');

var _package2 = _interopRequireDefault(_package);

var _read = require('./read');

var _read2 = _interopRequireDefault(_read);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var rm = (0, _denodeify2.default)(_rimraf2.default);

_ava2.default.beforeEach(function (t) {
	return new Promise(function ($return, $error) {
		return Promise.resolve(initRepository()).then(function ($await_3) {
			try {
				t.context.repos = [$await_3];
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

_ava2.default.afterEach.always(function (t) {
	return new Promise(function ($return, $error) {
		var $Try_1_Post = function () {
			try {
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this);var $Try_1_Catch = function (err) {
			try {
				console.log({ err });
				return $Try_1_Post();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this);
		try {
			return Promise.resolve(Promise.all(t.context.repos.map(function (repo) {
				return new Promise(function ($return, $error) {
					return $return(cleanRepository(repo));
				}.bind(this));
			}))).then(function ($await_4) {
				try {
					t.context.repos = [];
					return $Try_1_Post();
				} catch ($boundEx) {
					return $Try_1_Catch($boundEx);
				}
			}.bind(this), $Try_1_Catch);
		} catch (err) {
			$Try_1_Catch(err)
		}
	}.bind(this));
});

_ava2.default.serial('get edit commit message from git root', function (t) {
	return new Promise(function ($return, $error) {
		var expected, actual;
		return Promise.resolve((0, _fs.writeFile)('alpha.txt', 'alpha')).then(function ($await_5) {
			try {
				return Promise.resolve((0, _execa2.default)('git', ['add', '.'])).then(function ($await_6) {
					try {
						return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', 'alpha'])).then(function ($await_7) {
							try {
								expected = ['alpha\n\n'];
								return Promise.resolve((0, _read2.default)({ edit: true })).then(function ($await_8) {
									try {
										actual = $await_8;
										t.deepEqual(actual, expected);
										return $return();
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

_ava2.default.serial('get history commit messages', function (t) {
	return new Promise(function ($return, $error) {
		var expected, actual;
		return Promise.resolve((0, _fs.writeFile)('alpha.txt', 'alpha')).then(function ($await_9) {
			try {
				return Promise.resolve((0, _execa2.default)('git', ['add', 'alpha.txt'])).then(function ($await_10) {
					try {
						return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', 'alpha'])).then(function ($await_11) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['rm', 'alpha.txt'])).then(function ($await_12) {
									try {
										return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', 'remove alpha'])).then(function ($await_13) {
											try {

												expected = ['remove alpha\n\n', 'alpha\n\n'];
												return Promise.resolve((0, _read2.default)({})).then(function ($await_14) {
													try {
														actual = $await_14;
														t.deepEqual(actual, expected);
														return $return();
													} catch ($boundEx) {
														return $error($boundEx);
													}
												}.bind(this), $error);
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

_ava2.default.serial('get edit commit message from git subdirectory', function (t) {
	return new Promise(function ($return, $error) {
		var expected, actual;
		return Promise.resolve((0, _fs.mkdir)('beta')).then(function ($await_15) {
			try {
				return Promise.resolve((0, _fs.writeFile)('beta/beta.txt', 'beta')).then(function ($await_16) {
					try {
						process.chdir('beta');
						return Promise.resolve((0, _execa2.default)('git', ['add', '.'])).then(function ($await_17) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', 'beta'])).then(function ($await_18) {
									try {

										expected = ['beta\n\n'];
										return Promise.resolve((0, _read2.default)({ edit: true })).then(function ($await_19) {
											try {
												actual = $await_19;
												t.deepEqual(actual, expected);
												return $return();
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

_ava2.default.serial('get history commit messages from shallow clone', function (t) {
	return new Promise(function ($return, $error) {
		var _t$context$repos, repo, clone, err;

		_t$context$repos = (0, _slicedToArray3.default)(t.context.repos, 1), repo = _t$context$repos[0];
		return Promise.resolve((0, _fs.writeFile)('alpha.txt', 'alpha')).then(function ($await_20) {
			try {
				return Promise.resolve((0, _execa2.default)('git', ['add', 'alpha.txt'])).then(function ($await_21) {
					try {
						return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', 'alpha'])).then(function ($await_22) {
							try {
								return Promise.resolve(cloneRepository(_package2.default.repository.url, repo, '--depth', '1')).then(function ($await_23) {
									try {

										clone = $await_23;
										t.context.repos = [].concat((0, _toConsumableArray3.default)(t.context.repos), [clone]);

										return Promise.resolve(t.throws((0, _read2.default)({ from: 'master' }))).then(function ($await_24) {
											try {
												err = $await_24;
												t.true(err.message.indexOf('Could not get git history from shallow clone') > -1);
												return $return();
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

function initRepository() {
	return new Promise(function ($return, $error) {
		var previous, directory;

		previous = process.cwd();
		directory = (0, _path.join)((0, _os.tmpdir)(), rand());

		return Promise.resolve((0, _execa2.default)('git', ['init', directory])).then(function ($await_25) {
			try {

				process.chdir(directory);

				return Promise.resolve((0, _execa2.default)('git', ['config', 'user.email', 'test@example.com'])).then(function ($await_26) {
					try {
						return Promise.resolve((0, _execa2.default)('git', ['config', 'user.name', 'ava'])).then(function ($await_27) {
							try {

								return $return({ directory, previous });
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function cloneRepository(source, context) {
	var $args = arguments;return new Promise(function ($return, $error) {
		var directory, _len, args, _key;

		directory = (0, _path.join)((0, _os.tmpdir)(), rand());

		for (_len = $args.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			args[_key - 2] = $args[_key];
		}

		return Promise.resolve((0, _execa2.default)('git', ['clone'].concat(args, [source, directory]))).then(function ($await_28) {
			try {
				process.chdir(directory);

				return Promise.resolve((0, _execa2.default)('git', ['config', 'user.email', 'test@example.com'])).then(function ($await_29) {
					try {
						return Promise.resolve((0, _execa2.default)('git', ['config', 'user.name', 'ava'])).then(function ($await_30) {
							try {

								return $return({ directory, previous: context.previous });
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function cleanRepository(repo) {
	return new Promise(function ($return, $error) {
		if (repo.previous && repo.previous !== process.cwd()) {
			process.chdir(repo.previous);
		}

		return Promise.resolve((0, _pathExists2.default)(repo.directory)).then(function ($await_31) {
			try {
				if ($await_31) {
					return Promise.resolve(rm(repo.directory)).then(function ($await_32) {
						try {
							return $If_2.call(this);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				}

				function $If_2() {
					return $return();
				}

				return $If_2.call(this);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function rand() {
	return _crypto2.default.randomBytes(Math.ceil(6)).toString('hex').slice(0, 12);
}
//# sourceMappingURL=read.test.js.map