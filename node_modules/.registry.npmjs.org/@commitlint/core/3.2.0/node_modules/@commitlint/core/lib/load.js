'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _importFrom = require('import-from');

var _importFrom2 = _interopRequireDefault(_importFrom);

var _lodash = require('lodash');

var _rc = require('rc');

var _rc2 = _interopRequireDefault(_rc);

var _resolveFrom = require('resolve-from');

var _resolveFrom2 = _interopRequireDefault(_resolveFrom);

var _resolveExtends = require('./library/resolve-extends');

var _resolveExtends2 = _interopRequireDefault(_resolveExtends);

var _executeRule = require('./library/execute-rule');

var _executeRule2 = _interopRequireDefault(_executeRule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var w = function w(a, b) {
	return Array.isArray(b) ? b : undefined;
};
var valid = function valid(input) {
	return (0, _lodash.pick)(input, 'extends', 'rules', 'parserPreset');
};

exports.default = function () {
	var $args = arguments;return new Promise(function ($return, $error) {
		var seed, raw, config, opts, resolvedParserPreset, extended, preset, executed;
		seed = $args.length > 0 && $args[0] !== undefined ? $args[0] : {};

		raw = file();

		config = valid((0, _lodash.merge)(raw, seed));
		opts = (0, _lodash.merge)({ extends: [], rules: {} }, (0, _lodash.pick)(config, 'extends'));

		// Resolve parserPreset key
		if (typeof config.parserPreset === 'string') {
			resolvedParserPreset = (0, _resolveFrom2.default)(process.cwd(), config.parserPreset);

			config.parserPreset = {
				name: config.parserPreset,
				path: `./${_path2.default.posix.relative(process.cwd(), resolvedParserPreset)}`.split(_path2.default.sep).join('/'),
				opts: require(resolvedParserPreset)
			};
		}

		// Resolve extends key
		extended = (0, _resolveExtends2.default)(opts, {
			prefix: 'commitlint-config',
			cwd: raw.config ? _path2.default.dirname(raw.config) : process.cwd(),
			parserPreset: config.parserPreset
		});

		preset = valid((0, _lodash.mergeWith)(extended, config, w));

		// Await parser-preset if applicable
		if (typeof preset.parserPreset === 'object' && typeof preset.parserPreset.opts === 'object') {
			return Promise.resolve(preset.parserPreset.opts).then(function ($await_3) {
				try {
					preset.parserPreset.opts = $await_3;
					return $If_2.call(this);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		}

		// Execute rule config functions if needed

		function $If_2() {
			return Promise.resolve(Promise.all(['rules'].map(function (key) {
				return [key, preset[key]];
			}).map(function (item) {
				return new Promise(function ($return, $error) {
					var _item, key, value, executedValue;

					_item = (0, _slicedToArray3.default)(item, 2), key = _item[0], value = _item[1];
					return Promise.resolve(Promise.all((0, _lodash.entries)(value || {}).map(function (entry) {
						return (0, _executeRule2.default)(entry);
					}))).then(function ($await_4) {
						try {
							executedValue = $await_4;
							return $return([key, executedValue.reduce(function (registry, item) {
								var _item2 = (0, _slicedToArray3.default)(item, 2),
								    key = _item2[0],
								    value = _item2[1];

								registry[key] = value;
								return registry;
							}, {})]);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				}.bind(this));
			}))).then(function ($await_5) {
				try {
					executed = $await_5;

					// Merge executed config keys into preset
					return $return(executed.reduce(function (registry, item) {
						var _item3 = (0, _slicedToArray3.default)(item, 2),
						    key = _item3[0],
						    value = _item3[1];

						registry[key] = value;
						return registry;
					}, preset));
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		}

		return $If_2.call(this);
	}.bind(this));
};

function file() {
	var legacy = (0, _rc2.default)('conventional-changelog-lint');
	var legacyFound = typeof legacy.config === 'string';

	var found = resolveable('./commitlint.config');
	var raw = found ? (0, _importFrom2.default)(process.cwd(), './commitlint.config') : {};

	if (legacyFound && !found) {
		console.warn(`Using legacy ${_path2.default.relative(process.cwd(), legacy.config)}. Rename to commitlint.config.js to silence this warning.`);
	}

	if (legacyFound && found) {
		console.warn(`Ignored legacy ${_path2.default.relative(process.cwd(), legacy.config)} as commitlint.config.js superseeds it. Remove .conventional-changelog-lintrc to silence this warning.`);
	}

	if (found) {
		return raw;
	}

	return legacy;
}

function resolveable(id) {
	try {
		(0, _resolveFrom2.default)(process.cwd(), id);
		return true;
	} catch (err) {
		return false;
	}
}
module.exports = exports['default'];
//# sourceMappingURL=load.js.map