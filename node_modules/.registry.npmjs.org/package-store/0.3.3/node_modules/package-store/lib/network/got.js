"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const R = require("ramda");
const mkdirp = require("mkdirp-promise");
const path = require("path");
const createWriteStreamAtomic = require("fs-write-stream-atomic");
const ssri = require("ssri");
const unpackStream = require("unpack-stream");
const npmGetCredentialsByURI = require("npm/lib/config/get-credentials-by-uri");
const urlLib = require("url");
const normalizeRegistryUrl = require("normalize-registry-url");
const PQueue = require("p-queue");
const retry = require("retry");
exports.default = (client, opts) => {
    opts.rawNpmConfig['registry'] = normalizeRegistryUrl(opts.rawNpmConfig['registry'] || opts.registry);
    const retryOpts = {
        retries: opts.retries,
        factor: opts.factor,
        minTimeout: opts.minTimeout,
        maxTimeout: opts.maxTimeout,
        randomize: opts.randomize,
    };
    const getCredentialsByURI = npmGetCredentialsByURI.bind({
        get(key) {
            return opts.rawNpmConfig[key];
        }
    });
    let counter = 0;
    const networkConcurrency = opts.networkConcurrency || 16;
    const requestsQueue = new PQueue({
        concurrency: networkConcurrency,
    });
    function getJSON(url, registry, priority) {
        return __awaiter(this, void 0, void 0, function* () {
            return requestsQueue.add(() => new Promise((resolve, reject) => {
                const getOpts = {
                    auth: getCredentialsByURI(registry),
                    fullMetadata: false,
                };
                client.get(url, getOpts, (err, data, raw, res) => {
                    if (err)
                        return reject(err);
                    resolve(data);
                });
            }), { priority });
        });
    }
    function download(url, saveto, opts) {
        // Tarballs are requested first because they are bigger than metadata files.
        // However, when one line is left available, allow it to be picked up by a metadata request.
        // This is done in order to avoid situations when tarballs are downloaded in chunks
        // As much tarballs should be downloaded simultaneously as possible.
        const priority = (++counter % networkConcurrency === 0 ? -1 : 1) * 1000;
        return requestsQueue.add(() => __awaiter(this, void 0, void 0, function* () {
            yield mkdirp(path.dirname(saveto));
            const auth = opts.registry && getCredentialsByURI(opts.registry);
            // If a tarball is hosted on a different place than the manifest, only send
            // credentials on `alwaysAuth`
            const shouldAuth = auth && (auth.alwaysAuth ||
                !opts.registry ||
                urlLib.parse(url).host === urlLib.parse(opts.registry).host);
            const op = retry.operation(retryOpts);
            return new Promise((resolve, reject) => {
                op.attempt(currentAttempt => {
                    fetch(currentAttempt)
                        .then(resolve)
                        .catch(err => {
                        if (op.retry(err)) {
                            return;
                        }
                        reject(op.mainError());
                    });
                });
                function fetch(currentAttempt) {
                    return new Promise((resolve, reject) => {
                        client.fetch(url, { auth: shouldAuth && auth }, (err, res) => __awaiter(this, void 0, void 0, function* () {
                            if (err)
                                return reject(err);
                            if (res.statusCode !== 200) {
                                return reject(new Error(`Invalid response: ${res.statusCode}`));
                            }
                            const size = res.headers['content-length']
                                ? parseInt(res.headers['content-length'])
                                : null;
                            if (opts.onStart) {
                                opts.onStart(size, currentAttempt);
                            }
                            const onProgress = opts.onProgress;
                            let downloaded = 0;
                            res.on('data', (chunk) => {
                                downloaded += chunk.length;
                                if (onProgress)
                                    onProgress(downloaded);
                            });
                            const writeStream = createWriteStreamAtomic(saveto);
                            const stream = res
                                .on('error', reject)
                                .pipe(writeStream)
                                .on('error', reject);
                            Promise.all([
                                opts.integrity && ssri.checkStream(res, opts.integrity),
                                unpackStream.local(res, opts.unpackTo, {
                                    generateIntegrity: opts.generatePackageIntegrity,
                                }),
                                new Promise((resolve, reject) => {
                                    stream.on('close', () => {
                                        if (size !== null && size !== downloaded) {
                                            const err = new Error(`Actual size (${downloaded}) of tarball (${url}) did not match the one specified in \'Content-Length\' header (${size})`);
                                            err['code'] = 'BAD_TARBALL_SIZE';
                                            err['expectedSize'] = size;
                                            err['receivedSize'] = downloaded;
                                            reject(err);
                                            return;
                                        }
                                        resolve();
                                    });
                                }),
                            ])
                                .then(vals => resolve(vals[1]))
                                .catch(reject);
                        }));
                    })
                        .catch(err => {
                        err['attempts'] = currentAttempt;
                        err['resource'] = url;
                        throw err;
                    });
                }
            });
        }), { priority });
    }
    return {
        getJSON: R.memoize(getJSON),
        download,
    };
};
//# sourceMappingURL=got.js.map