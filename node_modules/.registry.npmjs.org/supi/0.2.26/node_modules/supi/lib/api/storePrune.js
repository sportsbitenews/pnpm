"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const extendOptions_1 = require("./extendOptions");
const getContext_1 = require("./getContext");
const pnpm_logger_1 = require("pnpm-logger");
const rimraf = require("rimraf-then");
const exists = require("path-exists");
const R = require("ramda");
const pFilter = require("p-filter");
const pLimit = require("p-limit");
const lock_1 = require("./lock");
const package_store_1 = require("package-store");
function default_1(maybeOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        const reporter = maybeOpts && maybeOpts.reporter;
        if (reporter) {
            pnpm_logger_1.streamParser.on('data', reporter);
        }
        const opts = extendOptions_1.default(maybeOpts);
        const ctx = yield getContext_1.default(opts);
        const removedProjects = yield getRemovedProject(ctx.storeIndex);
        if (!opts.lock) {
            yield run();
        }
        else {
            yield lock_1.default(ctx.storePath, run, { stale: opts.lockStaleDuration, locks: opts.locks });
        }
        function run() {
            return __awaiter(this, void 0, void 0, function* () {
                for (const pkgId in ctx.storeIndex) {
                    ctx.storeIndex[pkgId] = R.difference(ctx.storeIndex[pkgId], removedProjects);
                    if (!ctx.storeIndex[pkgId].length) {
                        delete ctx.storeIndex[pkgId];
                        yield rimraf(path.join(ctx.storePath, pkgId));
                        pnpm_logger_1.default.info(`- ${pkgId}`);
                    }
                }
                yield package_store_1.save(ctx.storePath, ctx.storeIndex);
            });
        }
        if (reporter) {
            pnpm_logger_1.streamParser.removeListener('data', reporter);
        }
    });
}
exports.default = default_1;
const limitExistsCheck = pLimit(10);
function getRemovedProject(storeIndex) {
    return __awaiter(this, void 0, void 0, function* () {
        const allProjects = R.uniq(R.unnest(R.values(storeIndex)));
        return yield pFilter(allProjects, (projectPath) => limitExistsCheck(() => __awaiter(this, void 0, void 0, function* () {
            const modulesDir = path.join(projectPath, 'node_modules');
            return !(yield exists(modulesDir));
        })));
    });
}
//# sourceMappingURL=storePrune.js.map